//a program is a list of statements, optionally entirely (empty program)
program: [statement ((";"|"\n") statement)*]

//TODO: can i make this just an expression and somehow differentiate
//  between an expr to evaluate and an expr in a definition?
?statement: terminal | definition | evaluate

//TODO: "@" behaves kind of like a class declaration
//TODO: allow params passed in to modify args of supertypes
terminal: "@" ID params -> terminal
  | "@" ID params EXTENDS types -> parameterized_terminal
types: type ("," type)*

definition: ID params "=" expr

params: "[" ID ("," ID)* "]" |

evaluate: expr

?expr: union
  | intersection
  | tuple
  | dict
  | "(" expr ")"
  | type
  // | conditional

union: expr "|" expr
intersection: expr "&" expr
tuple: "(" expr ("," expr)* ")"
dict: LBRACE (key_value ",")* RBRACE
?key_value: ID ":" expr
//TODO: find way to incorporate conditionals in the new "satisfied by" system
// conditional: expr "?" expr ":" expr

//types in expressions can be nested eg A[B[C]]
type: ID | ID "[" type ("," type)* "]"

ID: /[a-zA-Z_][a-zA-Z0-9_]*/
COMMENT: /#.*/
EXTENDS: "extends"

//this is just to get tokens for dict key/values
LBRACE: "{"
RBRACE: "}"

%import common.WS
%ignore WS
%ignore ";"
%ignore COMMENT
